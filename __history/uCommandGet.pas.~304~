unit uCommandGet;

interface

uses
  System.Classes, IdContext, IdCustomHTTPServer, System.Generics.Collections,
  superobject, System.NetEncoding, System.IOUtils, Vcl.Forms, uUniqueName, uDB, uCommon;

type
  TCommandGet = class(TComponent)
  private
    FContext: TIdContext;
    FRequestInfo: TIdHTTPRequestInfo;
    FResponseInfo: TIdHTTPResponseInfo;
    function ParseFirstSection(): string;
    procedure ProcessFiles(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
  public
    constructor Create(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    procedure Execute();
    property Context: TIdContext read FContext write FContext;
    property RequestInfo: TIdHTTPRequestInfo read FRequestInfo write FRequestInfo;
    property ResponseInfo: TIdHTTPResponseInfo read FResponseInfo write FResponseInfo;
  end;

implementation

uses
  uRPUsers,
  uRPTests,
  uRPFiles,
  uDecodePostRequest, System.SysUtils,
  DateUtils, uConst;

{ TCommandGet }
constructor TCommandGet.Create(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
begin
  FContext := AContext;
  FRequestInfo := ARequestInfo;
  FResponseInfo := AResponseInfo;
  Execute();
end;

procedure TCommandGet.Execute();
var
  firstSection: string;
  r: ISP<TResponses>;
  u: ISP<TRPUsers>;
  t: ISP<TRPTests>;
  f: ISP<TRPFiles>;
  uri: string;
begin
  r := TSP<TResponses>.Create(TResponses.Create(FRequestInfo, FResponseInfo));
  try
    firstSection := ParseFirstSection;
    if ( SameStr(firstSection,'Users')) then
      u := TSP<TRPUsers>.Create(TRPUsers.Create(FContext, FRequestInfo, FResponseInfo))
    else if ( SameStr(firstSection,'Test')) then
      t := TSP<TRPTests>.Create(TRPTests.Create(FContext, FRequestInfo, FResponseInfo))
    else if SameStr(firstSection,'Files') then
      f := TSP<TRPFiles>.Create(TRPFiles.Create(FContext, FRequestInfo, FResponseInfo))
    else
     begin
       uri := FRequestInfo.URI;
     end
    // else
    //  FResponseInfo.ResponseNo := 404;
  except
    on E: Exception do
      r.Error(e.Message);
  end;
end;


function TCommandGet.ParseFirstSection(): string;
var
  a: TArray<string>;
begin
  a := FRequestInfo.URI.Split(['/']);
  if Length(a) > 0 then
    Result := a[1]; // Parses Users from /Users/Add for example....
end;

procedure TCommandGet.ProcessFiles(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);

  function processRelUploadDir(): string;
  var
    absPath: string;
  begin
    Result := 'files\' + YearOf(Now).ToString() + '\' + MonthOf(Now()).ToString() + '\' + DayOf(Now).ToString(); //
    absPath := ExtractFilePath(Application.ExeName) + Result;
    if not TDirectory.Exists(absPath) then
      TDirectory.CreateDirectory(absPath);
  end;

var
  d: ISP<TDecodePostRequest>;
  fileName: string;
  relUploadDir: string;
  relWebFilePath: string;
  r: ISP<TResponses>;
  json: ISuperobject;
  uri: string;
begin
  {
  uri := ARequestInfo.URI;
  if ParseFirstSection(uri) = 'Files' then
    if (uri = '/Files/Send') then
    begin
      d := TSP<TDecodePostRequest>.Create();
      d.Execute(AContext, ARequestInfo, AResponseInfo);
      relWebFilePath := StringReplace(relUploadDir, '\', '/', [rfReplaceAll]) + '/' + fileName;
      json := SO;
      json.S['relWebFilePath'] := relWebFilePath;
      r := TSP<TResponses>.Create(TResponses.Create(ARequestInfo, AResponseInfo));
      r.OkWithJson(json.AsJSon(false, false)); // return relative webpath
    end;
   }
end;

end.

