unit uDecodePostRequest;

interface

uses
  System.SysUtils, System.Variants, System.Classes, Vcl.Graphics, Vcl.Controls,
  Vcl.Forms, Vcl.Dialogs, IdBaseComponent, IdComponent, IdCustomTCPServer,
  IdCustomHTTPServer, IdHTTPServer, Vcl.StdCtrls, HTTPApp, IdMultipartFormData,
  IdContext, System.IOUtils, System.NetEncoding, superobject, Contnrs,
  uSmartPointer,System.Generics.Collections;

type
  TPostParam = record
    Name: string;
    Value: string;
  end;

type
  TDecodePostRequest = class
  private
    FRelWebFileDir: string;
    FPostParams: ISP<TList<TPostParam>>;
    FJson: string;
    function ReadMultipartRequest(const aBoundary: Ansistring; ARequest: Ansistring; var AHeader: TStringList; var Data: Ansistring): Ansistring;
    procedure ParseJson(const aAsObject: TSuperTableString);
    procedure SetRelWebFileDir(const Value: string);
  public
    constructor Create();

    procedure Multipart(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    procedure FormURLEncoded(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    procedure Execute(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);

    property RelWebFileDir: string read FRelWebFileDir write SetRelWebFileDir;
    property PostParams: ISP<TList<TPostParam>> read FPostParams;
    property Json: string read FJson;
  end;

const
  MaxReadBlockSize = 8192;

implementation

uses
  System.StrUtils;

procedure TDecodePostRequest.Execute(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
var
  ss: ISP<TStringStream>;
begin
  AResponseInfo.Server := 'ver1';
  AResponseInfo.CacheControl := 'no-cache';

  if (Pos('multipart/form-data', LowerCase(ARequestInfo.ContentType)) > 0) and     // далее идёт обработка multipart
    (Pos('boundary', LowerCase(ARequestInfo.ContentType)) > 0) then
    Multipart(AContext, ARequestInfo, AResponseInfo)

  else if (Pos('application/x-www-form-urlencoded', LowerCase(ARequestInfo.ContentType)) > 0) then
    FormURLEncoded(AContext, ARequestInfo, AResponseInfo)

  else if (Pos('application/json', LowerCase(ARequestInfo.ContentType)) > 0) then
  begin
    ss := TSP<TStringStream>.Create();
    ss.LoadFromStream(ARequestInfo.PostStream);
    FJson := ss.DataString;
    // parse json... if needed or parse in other place
    //obj := SO(TNetEncoding.URL.Decode(allContent));
    //ParseJson(obj.AsObject, aPostParams);
  end;
end;

procedure TDecodePostRequest.FormURLEncoded(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
var
  ms: ISP<TMemoryStream>;
  boundary, bufferStr, allContent: Ansistring;
  header: ISP<TStringList>;
  hList: ISP<TStringList>;
  byteToRead, readedBytes, rSize: Integer;
  buffer: PAnsiChar;
  data: Ansistring;
  ss: ISP<TStringStream>;
begin
  ms := TSP<TMemoryStream>.Create();
  ms.LoadFromStream(ARequestInfo.PostStream);
  allContent := '';
  byteToRead := ARequestInfo.ContentLength;
  try
    while byteToRead > 0 do
    begin
      rSize := MaxReadBlockSize;
      if rSize > byteToRead then
        rSize := byteToRead;
      GetMem(buffer, rSize);
      try
        readedBytes := ms.Read(buffer^, rSize);
        SetString(bufferStr, buffer, readedBytes);
        allContent := allContent + bufferStr;
      finally
        FreeMem(buffer, rSize);
      end;
      byteToRead := ARequestInfo.ContentLength - Length(allContent);
    end;
  except
    on E: Exception do
    begin
      raise Exception.Create(' Exception Raised = ' + 'Class=' + E.ClassName + #13#1 + #13#10 + '  Message=' + E.Message);
      AResponseInfo.ContentText := E.Message;
      AResponseInfo.WriteContent;
    end;
  end;
end;

procedure TDecodePostRequest.ParseJson(const aAsObject: TSuperTableString);
//https://stackoverflow.com/questions/14082886/superobject-extract-all
var
  Names: ISuperObject;
  Name: string;
  Items: ISuperObject;
  Item: ISuperObject;
  idx: Integer;
  Value: string;
begin
  if Assigned(aAsObject) then
  begin
    Names := aAsObject.GetNames;
    Items := aAsObject.GetValues;

    for idx := 0 to Items.AsArray.Length - 1 do
    begin
      Name := Names.AsArray[idx].AsString;
      Item := Items.AsArray[idx];
      if Item.DataType = stObject then
        Value := '<Object>'
      else if Item.DataType = stArray then
        Value := '<Array>'
      else
        Value := Item.AsString;

       // do smth with json

      //postParams.Add(Name + '=' + Value);
     // postParams.json := Value; // returning only json object

      //if SameText(Name, 'id') then
       // WriteLn(Format('%s: %s', [aPrefix + Name, Value]));

       {
      if Item.DataType = stArray then
        for ArrayItem in Item do
          ProcessObject(ArrayItem.AsObject, aPrefix + Name + '.');

      if Item.DataType = stObject then
        ProcessObject(Item.AsObject, aPrefix + Name + '.');
        }
    end;
  end;
end;

//-------------------------------------------------
function TDecodePostRequest.ReadMultipartRequest(const aBoundary: Ansistring; ARequest: Ansistring; AHeader: ISP<TStringList>; var Data: Ansistring): Ansistring;
var
  Req, RHead: string;
  i: Integer;
begin
  Result := '';
  AHeader.Clear;
  Data := '';

  if (Pos(aBoundary, ARequest) < Pos(aBoundary + '--', ARequest)) and (Pos(aBoundary, ARequest) = 1) then
  begin
    Delete(ARequest, 1, Length(aBoundary) + 2);
    Req := Copy(ARequest, 1, Pos(aBoundary, ARequest) - 3);
    Delete(ARequest, 1, Length(Req) + 2);
    RHead := Copy(Req, 1, Pos(#13#10#13#10, Req) - 1);

    Delete(Req, 1, Length(RHead) + 4);
    AHeader.Text := RHead;
    for i := 0 to AHeader.Count - 1 do
      if Pos(':', AHeader.Strings[i]) > 0 then
        AHeader.Strings[i] := Trim(Copy(AHeader.Strings[i], 1, Pos(':', AHeader.Strings[i]) - 1)) + '=' + Trim(Copy(AHeader.Strings[i], Pos(':', AHeader.Strings[i]) + 1, Length(AHeader.Strings[i]) - Pos(':', AHeader.Strings[i])));
    Data := Req;
    Result := ARequest;
  end
end;

procedure TDecodePostRequest.SetRelWebFileDir(const Value: string);
begin
  FRelWebFileDir := Value;
end;

procedure TDecodePostRequest.Multipart(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);

  function ValueByName(aName: string): string;
  var
    i: Integer;
  begin
    Result := '';
    for i := 0 to FPostParams.Count - 1 do
      if FPostParams[i].Name = aName then
      begin
        result := FPostParams[i].Value;
        Break;
      end;
  end;

  function GetPostParam(aParamName: string): string;
  var
    value: string;
  begin
    value := ValueByName(aParamName);
    Result := IfThen(aParamName <> '', value, '');
  end;

const
  MaxReadBlockSize = 8192;
var
  ms: ISP<TMemoryStream>;
  fs: ISP<TFileStream>;
  boundary, bufferStr, allContent: Ansistring;
  header: ISP<TStringList>;
  byteToRead, readedBytes, rSize: Integer;
  buffer: PAnsiChar;
  data: Ansistring;
  hList: ISP<TStringList>;
  filename: string;
  dir: string;
  isUniqueName: string;
  postParam:TPostParam;
begin
  AResponseInfo.Server := 'ver1';
  AResponseInfo.CacheControl := 'no-cache';

  if (Pos('multipart/form-data', LowerCase(ARequestInfo.ContentType)) > 0) and
    (Pos('boundary', LowerCase(ARequestInfo.ContentType)) > 0) then
  begin
    header := TSP<TStringList>.Create();
    ExtractHeaderFields([';'], [' '], PChar(ARequestInfo.ContentType), header, False, False);
    boundary := header.Values['boundary'];

   // reading from postStream to allContent
    ms := TSP<TMemoryStream>.Create();
    ms.LoadFromStream(ARequestInfo.PostStream);
    allContent := '';
    byteToRead := ARequestInfo.ContentLength;
    while byteToRead > 0 do
    begin
      rSize := MaxReadBlockSize;
      if rSize > byteToRead then
        rSize := byteToRead;
      GetMem(buffer, rSize);
      try
        readedBytes := ms.Read(buffer^, rSize);
        SetString(bufferStr, buffer, readedBytes);
        allContent := allContent + bufferStr;
      finally
        FreeMem(buffer, rSize);
      end;
      byteToRead := ARequestInfo.ContentLength - Length(allContent);
    end;

    hList  := TSP<TStringList>.Create();
    // reading post blocks (params) from allContent to FPostParams
    if ARequestInfo.ContentLength = Length(allContent) then
      while Length(allContent) > Length('--' + boundary + '--' + #13#10) do
      begin
        header.Clear();
        hList.Clear();

        allContent := ReadMultipartRequest('--' + boundary, allContent, header, data);
        ExtractHeaderFields([';'], [' '], PChar(header.Values['Content-Disposition']), hList, False, True);

        postParam.Name := hList.Values['name'];
        postParam.Value := data;
        FPostParams.Add(postParam)
      end;

     // reading params
    filename := GetPostParam('filename');
    dir := GetPostParam('dir');
    isUniqueName := GetPostParam('isUniqueName');
    data := GetPostParam('attach');
    // writing file
    if (filename <> '') and (data <> '') then
    begin
      fs := TSP<TFileStream>.Create(TFileStream.Create(ExtractFilePath(Application.ExeName) + filename, fmCreate));
        try
          fs.WriteBuffer(Pointer(data)^, Length(data));
        except
          on E: EStreamError do
            raise Exception.Create('EStreamError EClassName' + E.ClassName + ' ' + 'EMessage ' + E.Message);
          on E: Exception do
            raise Exception.Create('EClassName' + E.ClassName + ' ' + 'EMessage ' + E.Message);
        end;
    end;
  end;
end;

constructor TDecodePostRequest.Create();
begin
  FPostParams := TSP<TList<TPostParam>>.Create();;
end;

{ TPostParams }
end.

